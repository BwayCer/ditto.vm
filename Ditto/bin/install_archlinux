#!/bin/bash
# ArchLinux 安裝腳本


__dirname=`dirname $0`
binDirPath="$__dirname"


opt_logfile=""
opt_exec=()
opt_chroot=()
fnMain() {
    local tmp opt val

    while [ -n 1 ]
    do
        opt="$1"
        val="$2"

        if [ -z "`echo "$opt" | grep "^-"`" ]; then
            for opt in "$@"
            do
                if [ -n "`echo "$opt" | grep "^-"`" ]; then
                    echo "[錯誤] 命令用法： \`<命令> [選項] [參數]\`。"
                    exit 1
                fi
            done

            break
        fi

        case "$opt" in
            "--logfile" )
                opt_logfile=$val
                shift 2
                ;;
            "--exec" )
                shift
                for tmp in "$@"
                do
                    opt_exec[ ${#opt_exec[@]} ]="$tmp"
                done
                shift $#
                ;;
            "--chroot" )
                shift
                for tmp in "$@"
                do
                    opt_chroot[ ${#opt_chroot[@]} ]="$tmp"
                done
                shift $#
                ;;
            * )
                fnRecordHistory echo "[錯誤] 非法選項 $opt"
                exit 1
                ;;
        esac
    done

    fnMainHandle "$@"
}

fnMainHandle() {
    local method execFunc

    if [ -n "$opt_logfile" ]; then
        fnRecordHistory_logfile=$opt_logfile
        fnArchChroot_logfile=$opt_logfile
    fi

    if [ ${#opt_exec[@]} -ne 0 ]; then
        method="exec"
        execFunc="${opt_exec[0]}"
    elif [ ${#opt_chroot[@]} -ne 0 ]; then
        method="chroot"
        execFunc="${opt_chroot[1]}"
    else
        tmpErrMsg='[錯誤] 請再次檢查參數。("--exec" 或 "--chroot")'
        fnRecordHistory echo -e "\e[01;31m${tmpErrMsg}\e[00m"
        exit 1
    fi

    fnAllowFunc "$execFunc"
    execFunc="$rtnAllowFunc"

    case "$method" in
        "exec" )
            opt_exec[0]="$execFunc"
            ${opt_exec[@]}
            ;;
        "chroot" )
            fnArchChroot ${opt_chroot[@]}
            ;;
    esac
}


fnRecordHistory() {
    fnRecordHistory_output i -- $@

    "$@"
    if [ $? -eq 0 ]; then
        fnRecordHistory_output i ok $@
    else
        fnRecordHistory_output i no $@
    fi
}
fnRecordHistory_logfile=""
fnRecordHistory_prefix="[`basename $0`]"
fnRecordHistory_output() {
    local method=$1; shift
    local state=$1; shift

    local lineNumber txt

    if [ -n "$state" ]; then
        txt=`date "+[%Y-%m-%d %H:%M:%S]"`" $fnRecordHistory_prefix $state: \$ $@"
    fi

    echo "$txt"

    if [ -n "$fnRecordHistory_logfile" ]; then
        if [ "$method" == "i" ]; then
            echo "$txt" >> "$fnRecordHistory_logfile"
        elif [ "$method" == "c" ]; then
            lineNumber=`cat "$fnRecordHistory_logfile" | wc -l`
            sed -i "${lineNumber}${method} $txt" "$fnRecordHistory_logfile"
        fi
    fi
}


rtnAllowFunc=""
fnAllowFunc() {
    local choCmd="$1"

    local allowFunc execFunc

    allowFunc=$allowFunc" fnHandleGrain   fnShowGrainInfo   fnHandleMirrorList "
    allowFunc=$allowFunc" fnPacman                                             "
    allowFunc=$allowFunc" fnBootProgram   fnBootProgram_uefi                   "

    if [ -z "$choCmd" ]; then
        tmpErrMsg="[錯誤] 請填入欲執行的功能。"
        fnRecordHistory echo -e "\e[01;31m${tmpErrMsg}\e[00m"
        exit 1
    elif [ -n "`echo "$choCmd" | grep "[^ ]\+"`" ] \
        && [ -n "`echo "$allowFunc" | grep -i " fn$choCmd "`" ]
    then
        execFunc=`echo "$allowFunc" | sed "s/^.* \(fn$choCmd\) .*$/\1/i"`
    else
        tmpErrMsg="[錯誤] 找不到欲執行的功能。"
        fnRecordHistory echo -e "\e[01;31m${tmpErrMsg}\e[00m"
        exit 1
    fi

    rtnAllowFunc="$execFunc"
}

fnArchChroot() {
    local mainMount="$1"; shift
    local runArgu="$@"

    local isoRunDir=/root/isoRun.tmp
    local isoRunFile=$isoRunDir/`basename "$0"`
    local isoLogFile=/root/isoLog.tmp

    fnRecordHistory cp -r "$__dirname" "$mainMount/$isoRunDir"
    if [ -n "$fnArchChroot_logfile" ]; then
        if [ -f "$mainMount/$isoLogFile" ]; then
            fnRecordHistory rm "$mainMount/$isoLogFile"
        fi
        fnRecordHistory touch "$mainMount/$isoLogFile"
        fnRecordHistory_output i txt \
            "echo \"sh $isoRunFile --logfile $isoLogFile --exec $runArgu\" | arch-chroot \"$mainMount\""
        echo "sh $isoRunFile --logfile $isoLogFile --exec $runArgu" | arch-chroot "$mainMount"
        fnRecordHistory_output i txt "cat \"$mainMount/$isoLogFile\" >> \"$fnArchChroot_logfile\""
        cat "$mainMount/$isoLogFile" >> "$fnArchChroot_logfile"
        fnRecordHistory rm "$mainMount/$isoLogFile"
    else
        fnRecordHistory echo "sh $isoRunFile --exec $runArgu" | arch-chroot "$mainMount"
    fi
    fnRecordHistory rm -r "$mainMount/$isoRunDir"
}
fnArchChroot_logfile=""

fnHandleGrain() {
    local val
    local mkfsList regexArgu
    local grain mkfsCmd mountPath

    mkfsList=$mkfsList" ext2     ext3     ext4  vfat        "
    mkfsList=$mkfsList" btrfs    cramfs   exfat fat  f2fs   "
    mkfsList=$mkfsList" jfs      minix    msdos ntfs nilfs2 "
    mkfsList=$mkfsList" reiserfs reiserfs xfs               "

    regexAllowArgu="^\([^:]\+:\)\{2\}[^:]\+$"

    for val in "$@"
    do
        if [ -z "`echo "$val" | grep "$regexAllowArgu"`" ]; then
            tmpErrMsg="[錯誤] 不符合預期的參數。"
            fnRecordHistory echo -e "\e[01;31m${tmpErrMsg}\e[00m"
            exit 1
        fi
    done

    for val in "$@"
    do
        grain=`      echo "$val" | cut -d ":" -f 1`
        mkfsCmd=`    echo "$val" | cut -d ":" -f 2`
        mountPathif=`echo "$val" | cut -d ":" -f 3`

        if [ -n "`echo "$mkfsCmd" | grep "[^ ]\+"`" ] \
            && [ -n "`echo "$mkfsList" | grep " $mkfsCmd "`" ]
        then
            mkfsCmd="mkfs.$mkfsCmd"
        fi

        if [ ! -d "$mountPathif" ]; then
            fnRecordHistory mkdir "$mountPathif"
        fi
        fnRecordHistory $mkfsCmd "$grain"
        fnRecordHistory mount "$grain" "$mountPathif"
    done
}

fnShowGrainInfo() {
    local device="$@"

    fnRecordHistory lsblk -o NAME,SIZE,RA,RO,RM,RAND,PARTFLAGS,PARTLABEL,PARTUUID $device
    fnRecordHistory lsblk -o NAME,MOUNTPOINT,FSTYPE,LABEL,UUID $device
}

fnHandleMirrorList() {
    local mirrorArea="$1"

    if [ ! -f "/etc/pacman.d/mirrorlist" ]; then
        tmpErrMsg='[錯誤] 鏡像表文件不存在。("/etc/pacman.d/mirrorlist")'
        fnRecordHistory echo -e "\e[01;31m${tmpErrMsg}\e[00m"
        exit 1
    fi

    local mirrorList serverList deleteList
    local lineNumber newMirrorList

    mirrorList=`cat /etc/pacman.d/mirrorlist`
    serverList=`echo -e "$mirrorList" | grep -n -B 1 "^Server = http" | grep "^[0-9]*-"`

    if [ -z "`echo -e "$serverList" | grep -i "$mirrorArea"`" ]; then
        tmpErrMsg="[錯誤] 找不到指定鏡像區域。"
        fnRecordHistory echo -e "\e[01;31m${tmpErrMsg}\e[00m"
        exit 1
    fi

    deleteList=`echo -e "$serverList" | grep -iv "$mirrorArea" | cut -d "-" -f 1`
    newMirrorList=$mirrorList

    for lineNumber in `echo -e "$deleteList" | sort -rn`
    do
        newMirrorList=`echo -e "$newMirrorList" | sed "$lineNumber,$(( $lineNumber + 1 ))d"`
    done

    fnRecordHistory_output i txt "echo -e \"$newMirrorList\" > /etc/pacman.d/mirrorlist"
    echo -e "$newMirrorList" > /etc/pacman.d/mirrorlist
    fnRecordHistory cat /etc/pacman.d/mirrorlist
}

fnBootProgram() {
    local mainMount="$1"
    local rootGrain="$2"
    local chooseBootSystem="$3"

    if [ -z "$mainMount" ]; then
        tmpErrMsg='[錯誤] 缺少跟目錄掛載位置參數。'
        fnRecordHistory echo -e "\e[01;31m${tmpErrMsg}\e[00m"
        exit 1
    elif [ -z "$rootGrain" ]; then
        tmpErrMsg='[錯誤] 缺少跟目錄硬碟位置參數。'
        fnRecordHistory echo -e "\e[01;31m${tmpErrMsg}\e[00m"
        exit 1
    fi

    local runArgu

    case "$chooseBootSystem" in
        "UEFI" | "uefi" )
            runArgu="bootProgram_uefi $rootGrain"
            ;;
        * )
            tmpErrMsg='[錯誤] 不符合預期的開機系統。'
            fnRecordHistory echo -e "\e[01;31m${tmpErrMsg}\e[00m"
            exit 1
            ;;
    esac

    fnRecordHistory_output i txt "genfstab -U \"$mainMount\" >> \"$mainMount/etc/fstab\""
    genfstab -U "$mainMount" >> "$mainMount/etc/fstab"
    fnRecordHistory cat "$mainMount/etc/fstab"
    fnRecordHistory fnArchChroot "$mainMount" $runArgu
}
fnBootProgram_uefi() {
    local rootGrain="$1"

    if [ -z "$rootGrain" ]; then
        tmpErrMsg='[錯誤] 缺少跟目錄硬碟位置參數。'
        fnRecordHistory echo -e "\e[01;31m${tmpErrMsg}\e[00m"
        exit 1
    fi

    local bootMenu partuuid

    fnRecordHistory mkinitcpio -p linux
    fnRecordHistory bootctl install
    fnRecordHistory_output i txt "echo -e \"default arch\ntimeout 3\" > /boot/loader/loader.conf"
    echo -e "default arch\ntimeout 3" > /boot/loader/loader.conf
    fnRecordHistory cat /boot/loader/loader.conf

    partuuid=`blkid -s PARTUUID $rootGrain | sed "s/.*PARTUUID=\"\([a-f0-9-]\+\)\"/\1/"`
    bootMenu=$bootMenu"title Archlinux\n"
    bootMenu=$bootMenu"linux /vmlinuz-linux\n"
    bootMenu=$bootMenu"initrd /initramfs-linux.img\n"
    bootMenu=$bootMenu"options root=PARTUUID=$partuuid rw"
    fnRecordHistory_output i txt "echo -e \"$bootMenu\" > /boot/loader/entries/arch.conf"
    echo -e "$bootMenu" > /boot/loader/entries/arch.conf
    fnRecordHistory cat /boot/loader/entries/arch.conf
}

fnPacman() {
    local opt="$1"
    local pkgs="$2"

    local tmp

    if [ -z "`echo "$opt" | grep "^-[A-Za-z0-9_-]\+"`" ]; then
        pkgs=$opt
        opt=""
    fi

    tmp=0
    [ -n "`echo "$opt" | grep "^-Sy"`" ] && [ -z "$pkgs" ] && tmp=1

    if [ $tmp -ne 1 ] && [ -z "`echo "$pkgs" | grep "[A-Za-z0-9_-]\+"`" ]; then
        tmpErrMsg="[錯誤] 不符合預期的程式包參數。"
        fnRecordHistory echo -e "\e[01;31m${tmpErrMsg}\e[00m"
        exit 1
    fi


    local tmpRegex
    local val
    local funcPkg=""
    local otherPkg=""

    tmp=$pkgs
    tmpRegex="^\([A-Za-z0-9_-]\+\)\(,\(.\+\)\)\?$"

    while [ -n "$tmp" ]
    do
        fnAllowPkg "`echo "$tmp" | sed "s/$tmpRegex/\1/"`"
        if [ "$rtnAllowPkg_method" == "func" ]; then
            funcPkg="$rtnAllowPkg_pkgName ; "
        else
            otherPkg="$rtnAllowPkg_pkgName "
        fi

        val=`echo "$tmp" | sed "s/$tmpRegex/\3/"`
        if [ -n "$val" ]; then
            tmp=$val
        else
            tmp=""
        fi
    done


    if [ -n "$funcPkg" ]; then
        $funcPkg
    fi

    if [ -n "$opt" ] && [ -n "$otherPkg" ]; then
        fnRecordHistory pacman $opt --noconfirm $otherPkg
    elif [ -z "$opt" ] && [ -n "$otherPkg" ]; then
        fnRecordHistory pacman -S --noconfirm $otherPkg
    elif [ -n "`echo "$opt" | grep "^-Sy"`" ]; then
        fnRecordHistory pacman $opt --noconfirm
    fi
}
rtnAllowPkg_method=""
rtnAllowPkg_pkgName=""
fnAllowPkg() {
    local choPkg="$1"

    local allowPkg
    local method=""
    local pkgName=""

    allowPkg=$allowPkg" openssh "

    if [ -n "`echo "$allowPkg" | grep -i " $choPkg "`" ]; then
        method="func"
        pkgName=`echo "$allowPkg" | sed "s/^.* \($choPkg\) .*$/fnPacman_\1/i"`
    else
        method="other"
        pkgName=$choPkg
    fi

    rtnAllowPkg_method="$method"
    rtnAllowPkg_pkgName="$pkgName"
}
fnPacman_openssh() {
    local lineNumber

    pacman -S --noconfirm openssh

    if [ ! -f /etc/ssh/sshd_config ]; then
        tmpErrMsg="[錯誤] 找不到設定文件。"'("/etc/ssh/sshd_config")'
        fnRecordHistory echo -e "\e[01;31m${tmpErrMsg}\e[00m"
        exit 1
    fi

    if [ -z "`grep "^PasswordAuthentication no$" /etc/ssh/sshd_config`" ]; then
        lineNumber=`grep -n "^#PasswordAuthentication yes" /etc/ssh/sshd_config | cut -d ":" -f 1`
        fnRecordHistory sed -i "$(( $lineNumber + 1 ))i PasswordAuthentication no" /etc/ssh/sshd_config
        fnRecordHistory grep "PasswordAuthentication" /etc/ssh/sshd_config
    fi

    fnRecordHistory "$binDirPath/createVmPass"
}


fnMain "$@"

